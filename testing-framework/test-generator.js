/**
 * @fileoverview Test Generator for Dev Framework Testing System
 * Creates test scaffolds BEFORE implementation (TDD approach)
 */

const fs = require('fs').promises;
const path = require('path');
const ComplexityAnalyzer = require('./complexity-analyzer');

class TestGenerator {
  constructor() {
    this.analyzer = new ComplexityAnalyzer();
    this.testsDir = path.resolve(process.cwd(), 'tests');
  }

  async generateTests(feature) {
    const analysis = await this.analyzer.analyze(feature);
    const testTypes = this.determineTestTypes(analysis.level);
    const context = this.extractContext(feature);

    const generatedTests = [];
    for (const testType of testTypes) {
      const testFile = await this.generateTestFile(testType, context, feature, analysis);
      generatedTests.push(testFile);
    }

    const testPlan = this.createTestPlan(feature, analysis, generatedTests);

    return {
      analysis,
      generatedTests,
      testPlan,
      instructions: this.getInstructions(analysis.level),
    };
  }

  determineTestTypes(level) {
    const testTypeMap = {
      trivial: [],
      simple: ['integration'],
      moderate: ['integration', 'unit'],
      complex: ['integration', 'unit', 'e2e'],
      critical: ['integration', 'unit', 'e2e', 'security'],
    };

    return testTypeMap[level] || ['integration'];
  }

  extractContext(feature) {
    const context = {
      featureId: feature.id || 'feature-' + Date.now(),
      title: feature.title || 'Feature',
      description: feature.description || '',
      requirements: feature.requirements || feature.acceptanceCriteria || [],
      technicalDetails: feature.technicalDetails || {},
    };

    const text = `${context.title} ${context.description}`.toLowerCase();

    if (text.includes('component') || text.includes('button') || text.includes('form')) {
      context.type = 'component';
      context.componentName = this.inferComponentName(context.title);
    } else if (text.includes('api') || text.includes('endpoint')) {
      context.type = 'api';
      context.endpoint = this.inferEndpoint(context.title);
    } else if (text.includes('hook') || text.includes('use')) {
      context.type = 'hook';
      context.hookName = this.inferHookName(context.title);
    } else {
      context.type = 'feature';
    }

    return context;
  }

  async generateTestFile(testType, context, feature, analysis) {
    const fileName = this.generateFileName(testType, context);
    const filePath = this.getFilePath(testType, fileName);
    const content = this.generateContent(testType, context, feature);

    await fs.mkdir(path.dirname(filePath), { recursive: true });
    await fs.writeFile(filePath, content, 'utf8');

    return {
      type: testType,
      path: filePath,
      fileName,
      status: 'created',
      expectedToFail: true,
    };
  }

  generateFileName(testType, context) {
    const base = context.featureId.replace(/[^a-z0-9-]/gi, '-').toLowerCase();

    const suffixes = {
      integration: '.integration.test.ts',
      unit: '.unit.test.ts',
      e2e: '.e2e.test.ts',
      security: '.security.test.ts',
    };

    return base + (suffixes[testType] || '.test.ts');
  }

  getFilePath(testType, fileName) {
    const dirs = {
      integration: 'integration',
      unit: 'unit',
      e2e: 'e2e',
      security: 'security',
    };

    const dir = dirs[testType] || 'integration';
    return path.join(this.testsDir, dir, fileName);
  }

  generateContent(testType, context, feature) {
    const template = `/**
 * @fileoverview ${testType.charAt(0).toUpperCase() + testType.slice(1)} tests for ${context.title}
 * Generated by Dev Framework - TDD approach
 * 
 * These tests are designed to FAIL initially.
 * Implement the feature to make them pass.
 */

describe('${context.title}', () => {
  describe('Happy Path', () => {
    it('should complete the primary user flow', () => {
      // TODO: Implement this test
      expect(true).toBe(false); // FAILING - Implement feature first
    });
  });

  describe('Requirements', () => {
${(feature.requirements || []).map((req, i) => `    it('should ${req}', () => {
      // TODO: Implement requirement test
      expect(true).toBe(false); // FAILING - Implement requirement
    });`).join('\n\n')}
  });

  describe('Error Handling', () => {
    it('should handle invalid input gracefully', () => {
      // TODO: Implement error handling test
      expect(true).toBe(false); // FAILING - Add error handling
    });
  });
});
`;

    return template;
  }

  createTestPlan(feature, analysis, generatedTests) {
    return {
      featureId: feature.id,
      title: feature.title,
      complexity: analysis.level,
      profile: analysis.profile,
      coverageTargets: analysis.profile.coverage,
      generatedTests: generatedTests.map((t) => ({
        type: t.type,
        path: t.path,
        status: t.status,
      })),
      testStrategy: analysis.profile.testStrategy,
      estimatedTime: this.estimateTime(analysis.level),
    };
  }

  estimateTime(level) {
    const times = {
      trivial: '5 minutes',
      simple: '15-30 minutes',
      moderate: '30-60 minutes',
      complex: '1-2 hours',
      critical: '2-4 hours',
    };

    return times[level] || '1 hour';
  }

  getInstructions(level) {
    const instructions = {
      trivial: [
        'Run existing tests to ensure no regressions',
        'No new tests required',
      ],
      simple: [
        'Run generated integration test',
        'Implement code to make test pass',
        'Focus on happy path',
      ],
      moderate: [
        'Start with failing integration tests',
        'Implement features to pass tests',
        'Add unit tests for business logic',
        'Refactor with confidence',
      ],
      complex: [
        'Follow TDD workflow strictly',
        'Implement one test at a time',
        'Write minimum code to pass',
        'Refactor when tests pass',
        'Use cross-LLM review for critical logic',
      ],
      critical: [
        'Review test plan with team',
        'Break into smaller features if possible',
        'Implement incrementally',
        'Run security and performance tests',
        'Mandatory cross-LLM review',
      ],
    };

    return instructions[level] || instructions.moderate;
  }

  inferComponentName(title) {
    const words = title.split(/\s+/);
    return words
      .map((w) => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
      .join('');
  }

  inferEndpoint(title) {
    const words = title.toLowerCase().split(/\s+/);
    return '/api/' + words.filter((w) => w.length > 2).join('-');
  }

  inferHookName(title) {
    const words = title.toLowerCase().split(/\s+/);
    return 'use' + words
      .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
      .join('');
  }
}

module.exports = TestGenerator;
